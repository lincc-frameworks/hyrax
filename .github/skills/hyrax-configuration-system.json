{
  "name": "Hyrax Configuration System",
  "description": "Comprehensive guide for working with Hyrax's TOML configuration system, ConfigDict, and Pydantic validation",
  "version": "1.0.0",
  "tags": ["configuration", "config", "toml", "pydantic"],
  "instructions": "This skill provides detailed guidance on Hyrax's configuration system, including ConfigDict usage, default requirements, immutability rules, and common pitfalls.\n\n## When to Use\n\nUse this skill when:\n- Working with Hyrax configuration files\n- Encountering \"config key not found\" errors\n- Adding new configuration parameters\n- Understanding ConfigDict vs regular dict\n- Debugging configuration validation issues\n- Understanding the `key = false` convention\n\n## Configuration System Overview\n\n### Key Principles\n\n1. **All keys need defaults**: Every config key MUST have a default in `hyrax_default_config.toml`\n2. **Config is immutable**: No runtime mutations allowed after creation\n3. **Use ConfigDict, not dict**: ConfigDict catches missing defaults at runtime\n4. **Pydantic validation**: Schemas validate structure and types\n5. **Hierarchical merging**: User config merges with defaults\n\n### Configuration Files\n\n**Default config**: `src/hyrax/hyrax_default_config.toml`\n```toml\n# All possible keys with sensible defaults\n[model]\nname = \"HyraxAutoencoderV2\"\nlatent_dim = 128\nlearning_rate = 0.001\n\n[data]\nname = \"DownloadedLSSTDataset\"\nbatch_size = 32\nnum_workers = 4\n\n[training]\nepochs = 100\ndevice = \"cuda\"\n```\n\n**User config**: `config.toml`\n```toml\n# Override only what you need\n[model]\nname = \"MyCustomModel\"\nlatent_dim = 256\n\n[training]\nepochs = 50\n```\n\n**Result**: User config merged with defaults\n```toml\n[model]\nname = \"MyCustomModel\"        # User override\nlatent_dim = 256              # User override\nlearning_rate = 0.001         # Default\n\n[data]\nname = \"DownloadedLSSTDataset\"  # Default\nbatch_size = 32               # Default\nnum_workers = 4               # Default\n\n[training]\nepochs = 50                   # User override\ndevice = \"cuda\"               # Default\n```\n\n## ConfigDict vs Dict\n\n### Why ConfigDict?\n\n**Regular dict** (DON'T USE):\n```python\nconfig = {\"model\": {\"name\": \"MyModel\"}}\n\n# Silent failure - returns None\nvalue = config.get(\"nonexistent_key\", None)\n\n# KeyError only if you access directly\nvalue = config[\"nonexistent_key\"]  # KeyError\n```\n\n**ConfigDict** (USE THIS):\n```python\nfrom hyrax.config_utils import ConfigDict\n\nconfig = ConfigDict({\"model\": {\"name\": \"MyModel\"}})\n\n# Fails immediately with helpful error\nvalue = config[\"nonexistent_key\"]  # Raises ConfigKeyError\n\n# Also fails for nested keys\nvalue = config[\"model\"][\"nonexistent_param\"]  # Raises ConfigKeyError\n```\n\n### Creating ConfigDict\n\n```python\nfrom hyrax.config_utils import ConfigDict, ConfigManager\n\n# Method 1: From file\nconfig = ConfigManager.load_config(\"config.toml\")\n# Returns ConfigDict with defaults merged\n\n# Method 2: From dict\nconfig_dict = {\"model\": {\"name\": \"MyModel\"}}\nconfig = ConfigDict(config_dict)\n\n# Method 3: From Hyrax\nfrom hyrax import Hyrax\nhyrax = Hyrax(config_file=\"config.toml\")\nconfig = hyrax.config  # ConfigDict\n```\n\n## Configuration Immutability\n\n### Why Immutable?\n\n- Ensures reproducibility\n- Prevents accidental modifications\n- Config serves as experiment record\n- Avoids hard-to-debug state changes\n\n### Correct Usage\n\n```python\n# ✅ CORRECT: Read-only access\nmodel_name = config[\"model\"][\"name\"]\nlearning_rate = config[\"training\"][\"learning_rate\"]\n\n# ✅ CORRECT: Create new config for modifications\nnew_config_dict = config.to_dict()\nnew_config_dict[\"model\"][\"name\"] = \"NewModel\"\nnew_config = ConfigDict(new_config_dict)\n\n# ✅ CORRECT: Modify before creating ConfigDict\nconfig_dict = {\"model\": {\"name\": \"Model1\"}}\nconfig_dict[\"model\"][\"name\"] = \"Model2\"\nconfig = ConfigDict(config_dict)  # Now immutable\n```\n\n### Incorrect Usage\n\n```python\n# ❌ WRONG: Attempting to modify after creation\nconfig[\"model\"][\"name\"] = \"NewModel\"  # Error!\n\n# ❌ WRONG: Trying to add new keys\nconfig[\"new_section\"] = {}  # Error!\n\n# ❌ WRONG: Modifying nested dicts\nconfig[\"model\"][\"new_param\"] = 100  # Error!\n```\n\n## Adding New Configuration Keys\n\n### Step-by-Step Process\n\n#### 1. Add to Default Config\n\nFile: `src/hyrax/hyrax_default_config.toml`\n\n```toml\n# Add new key with sensible default\n[model]\nname = \"HyraxAutoencoderV2\"\nlatent_dim = 128\nnew_parameter = 10  # ← ADD THIS\n```\n\n**CRITICAL**: EVERY key must have a default, even if it's `false` (see next section).\n\n#### 2. Update Pydantic Schema (Optional but Recommended)\n\nFile: `src/hyrax/config_schemas/model_config.py`\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass ModelConfig(BaseModel):\n    \"\"\"Pydantic schema for model configuration.\"\"\"\n    name: str = Field(description=\"Model name\")\n    latent_dim: int = Field(gt=0, description=\"Latent dimension\")\n    new_parameter: int = Field(default=10, description=\"New parameter\")  # ← ADD THIS\n```\n\n#### 3. Use in Code\n\n```python\ndef my_function(config):\n    \"\"\"Use new config parameter.\"\"\"\n    new_value = config[\"model\"][\"new_parameter\"]\n    # ... use new_value\n```\n\n#### 4. Document in HYRAX_GUIDE.md\n\nAdd to configuration reference:\n```markdown\n### Model Configuration\n\n- `new_parameter` (int, default: 10): Description of what this parameter does\n```\n\n## The `key = false` Convention\n\n### What Does `key = false` Mean?\n\n**Convention**: `key = false` in TOML means the key is optional and defaults to `None` in Python.\n\n**In TOML**:\n```toml\n[model]\noptional_param = false  # Means \"None\" or \"not set\"\n```\n\n**In Python**:\n```python\n# When key = false in TOML\nconfig[\"model\"][\"optional_param\"]  # Returns None\n\n# Check if set\nif config[\"model\"][\"optional_param\"]:\n    use_param(config[\"model\"][\"optional_param\"])\nelse:\n    # Use default behavior\n    pass\n```\n\n### When to Use `key = false`\n\n```toml\n# Use for optional features\n[model]\nuse_batch_norm = false  # Optional: batch normalization\ndropout_rate = false    # Optional: dropout\n\n# Use for optional paths\n[data]\npretrained_weights = false  # Optional: path to weights\ncustom_transform = false     # Optional: custom transform\n\n# Use for optional integrations\n[logging]\nmlflow_uri = false       # Optional: MLflow tracking\nwandb_project = false    # Optional: Weights & Biases\n```\n\n### User Overrides\n\nUser can enable by setting to actual value:\n```toml\n# User config.toml\n[model]\nuse_batch_norm = true\ndropout_rate = 0.5\n\n[data]\npretrained_weights = \"/path/to/weights.pt\"\n```\n\n## Configuration Hierarchy\n\n### Merge Order\n\n1. **Built-in defaults**: `hyrax_default_config.toml`\n2. **Component defaults**: `<component>_default_config.toml`\n3. **External plugin defaults**: `<package>/default_config.toml`\n4. **User config**: `config.toml`\n\nLater configs override earlier ones.\n\n### Example Merge\n\n**hyrax_default_config.toml**:\n```toml\n[model]\nname = \"HyraxAutoencoderV2\"\nlatent_dim = 128\nlearning_rate = 0.001\n```\n\n**my_model_default_config.toml**:\n```toml\n[model]\nlatent_dim = 256  # Component default overrides\ncustom_param = 42\n```\n\n**config.toml** (user):\n```toml\n[model]\nname = \"MyModel\"  # User overrides\nlearning_rate = 0.0001\n```\n\n**Final merged config**:\n```toml\n[model]\nname = \"MyModel\"          # From user\nlatent_dim = 256          # From component\nlearning_rate = 0.0001    # From user\ncustom_param = 42         # From component\n```\n\n## Pydantic Validation\n\n### Why Pydantic?\n\n- Type checking at runtime\n- Helpful error messages\n- Schema documentation\n- Validation rules (gt, lt, regex, etc.)\n\n### Validation Schemas\n\nLocation: `src/hyrax/config_schemas/`\n\n```python\nfrom pydantic import BaseModel, Field, validator\n\nclass ModelConfig(BaseModel):\n    \"\"\"Model configuration schema.\"\"\"\n    \n    name: str = Field(description=\"Model name\")\n    latent_dim: int = Field(gt=0, description=\"Latent dimension must be positive\")\n    learning_rate: float = Field(gt=0, lt=1, description=\"Learning rate in (0, 1)\")\n    \n    @validator(\"name\")\n    def name_not_empty(cls, v):\n        if not v or v.strip() == \"\":\n            raise ValueError(\"Model name cannot be empty\")\n        return v\n```\n\n### Using Validation\n\n```python\nfrom hyrax.config_schemas import ModelConfig\n\n# Validate config section\nmodel_config = ModelConfig(**config[\"model\"])\n\n# Pydantic raises ValidationError if invalid\n# Example errors:\n# - \"latent_dim must be greater than 0\"\n# - \"learning_rate must be greater than 0 and less than 1\"\n# - \"name cannot be empty\"\n```\n\n## Common Configuration Errors\n\n### Error 1: Config Key Not Found\n\n**Error**:\n```\nConfigKeyError: Key 'new_param' not found in config\n```\n\n**Cause**: Key not in `hyrax_default_config.toml`\n\n**Solution**:\n1. Add to `src/hyrax/hyrax_default_config.toml`:\n   ```toml\n   [section]\n   new_param = default_value\n   ```\n2. If optional, use `new_param = false`\n\n### Error 2: Type Mismatch\n\n**Error**:\n```\nValidationError: latent_dim: value is not a valid integer\n```\n\n**Cause**: Config value has wrong type\n\n**Solution**:\nFix in config file:\n```toml\n# ❌ WRONG\n[model]\nlatent_dim = \"128\"  # String\n\n# ✅ CORRECT\n[model]\nlatent_dim = 128    # Integer\n```\n\n### Error 3: Missing Section\n\n**Error**:\n```\nConfigKeyError: Key 'model' not found in config\n```\n\n**Cause**: Entire config section missing\n\n**Solution**:\nAdd section to `hyrax_default_config.toml`:\n```toml\n[model]\nname = \"HyraxAutoencoderV2\"\nlatent_dim = 128\n```\n\n### Error 4: Attempting Mutation\n\n**Error**:\n```\nAttributeError: ConfigDict is immutable\n```\n\n**Cause**: Trying to modify ConfigDict after creation\n\n**Solution**:\nCreate new config instead:\n```python\n# Convert to dict, modify, create new ConfigDict\nnew_dict = config.to_dict()\nnew_dict[\"model\"][\"name\"] = \"NewModel\"\nnew_config = ConfigDict(new_dict)\n```\n\n## Configuration Best Practices\n\n### 1. Always Use ConfigDict\n\n```python\n# ✅ CORRECT\nfrom hyrax.config_utils import ConfigDict\nconfig = ConfigDict(config_dict)\n\n# ❌ WRONG\nconfig = config_dict  # Just a dict\n```\n\n### 2. Provide Sensible Defaults\n\n```toml\n# ✅ CORRECT: Reasonable defaults that work out of box\n[training]\nbatch_size = 32\nlearning_rate = 0.001\nepochs = 100\n\n# ❌ WRONG: Defaults that require user to change\n[training]\nbatch_size = 1000000  # Unrealistic\nlearning_rate = 1.0   # Too high\nepochs = 0            # Won't train\n```\n\n### 3. Use `key = false` for Optional Features\n\n```toml\n# ✅ CORRECT: Optional features default to false\n[logging]\nmlflow_uri = false\nwandb_project = false\n\n# ❌ WRONG: Optional features with dummy values\n[logging]\nmlflow_uri = \"\"           # Empty string is confusing\nwandb_project = \"none\"    # \"none\" might be actual project name\n```\n\n### 4. Validate Early\n\n```python\n# ✅ CORRECT: Validate config on load\nconfig = ConfigManager.load_config(\"config.toml\")\n# Validation happens here - fail fast\n\n# ❌ WRONG: Validate late in processing\n# ... hours of processing ...\n# Finally try to use config key - error!\n```\n\n### 5. Document Configuration\n\n```python\nclass MyModel:\n    \"\"\"My model.\n    \n    Configuration:\n        model.name: Model identifier\n        model.latent_dim: Latent space dimensionality (must be > 0)\n        model.learning_rate: Learning rate for optimizer (0 < lr < 1)\n    \"\"\"\n```\n\n## Working with External Plugins\n\n### Plugin Config Loading\n\n```toml\n# User config.toml\n[model]\nname = \"external_package.CustomModel\"  # External model\n```\n\nHyrax will:\n1. Import `external_package.CustomModel`\n2. Look for `external_package/default_config.toml`\n3. Merge with hyrax defaults and user config\n\n### Plugin Default Config\n\nLocation: `external_package/default_config.toml`\n\n```toml\n[model]\nlatent_dim = 512\ncustom_param = \"value\"\n\n[external_package_settings]\nplugin_option = true\n```\n\n## Debugging Configuration\n\n### Print Current Config\n\n```python\nfrom hyrax import Hyrax\n\nhyrax = Hyrax(config_file=\"config.toml\")\n\n# Print entire config\nprint(hyrax.config.to_dict())\n\n# Print specific section\nprint(hyrax.config[\"model\"])\n\n# Pretty print\nimport json\nprint(json.dumps(hyrax.config.to_dict(), indent=2))\n```\n\n### Check Default Values\n\n```bash\n# View default config\ncat src/hyrax/hyrax_default_config.toml\n\n# Search for specific key\ngrep -n \"key_name\" src/hyrax/hyrax_default_config.toml\n```\n\n### Validate Config File\n\n```python\n# Load and validate\nfrom hyrax.config_utils import ConfigManager\n\ntry:\n    config = ConfigManager.load_config(\"config.toml\")\n    print(\"Config valid!\")\nexcept Exception as e:\n    print(f\"Config error: {e}\")\n```\n\n## Related Skills\n\n- For using config in components, see: **Adding Hyrax Components**\n- For overall workflow, see: **Hyrax Development Workflow**\n- For testing config, see: **Hyrax Testing Strategy**\n\n## References\n\n- Configuration guide: [HYRAX_GUIDE.md](../../HYRAX_GUIDE.md#configuration-system)\n- Default config: `src/hyrax/hyrax_default_config.toml`\n- ConfigDict implementation: `src/hyrax/config_utils.py`\n- Pydantic schemas: `src/hyrax/config_schemas/`"
}
